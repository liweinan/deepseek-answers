# 理解递归和循环

在开始探讨递归是否可以全部改写为循环之前，我首先需要明确什么是递归，什么是循环，以及它们各自的特点。

**递归（Recursion）**：在计算机科学中，递归是指一个函数在其定义中直接或间接调用自身的方法。递归通常用于解决可以分解为相似子问题的问题，例如树的遍历、阶乘计算、斐波那契数列等。

**循环（Loop）**：循环是通过重复执行一段代码直到满足某个条件为止的控制结构。常见的循环结构包括`for`循环、`while`循环和`do-while`循环等。

### 递归与循环的对比

递归和循环都可以用来重复执行某些操作，但它们的工作方式不同：

1. **递归**：
    - 基于函数调用。
    - 每次递归调用都会在调用栈上创建一个新的栈帧，保存当前的状态。
    - 需要有明确的终止条件（base case），否则会导致无限递归和栈溢出。
    - 代码通常更简洁，更符合问题的数学定义。
    - 可能会因为栈深度过大而导致栈溢出。

2. **循环**：
    - 基于迭代。
    - 不需要额外的函数调用开销，通常使用固定的内存空间。
    - 通过修改循环变量来控制循环的终止。
    - 代码可能更冗长，但效率通常更高。
    - 不会因为深度问题导致栈溢出。

### 递归转循环的必要性

虽然递归在某些情况下代码更简洁，但它也有一些缺点：

- **栈溢出**：对于深度较大的递归，可能会耗尽调用栈的空间。
- **性能开销**：函数调用比循环迭代有更多的开销，如参数传递、栈帧创建等。
- **可读性和调试**：对于不熟悉递归的人来说，递归代码可能较难理解和调试。

因此，有时候我们需要将递归算法转换为循环，以提高效率和避免栈溢出。

### 递归转循环的可能性

现在回到核心问题：**是否所有的递归都可以改写为循环？是否有通用的范式？**

从理论计算机科学的角度来看，**所有的递归函数都可以转换为等价的循环形式**。这是因为递归和循环在计算能力上是等价的，它们都是图灵完备的。也就是说，任何可以用递归解决的问题，也可以用循环来解决，反之亦然。

### 递归转循环的通用方法

将递归转换为循环的通用方法是**使用栈来模拟递归的调用过程**。递归的本质是利用系统的调用栈来保存每一层的状态，我们可以显式地使用一个数据结构（如栈）来手动保存这些状态，从而将递归转换为迭代。

#### 通用步骤：

1. **确定递归函数的参数和局部变量**：这些是需要保存在栈中的状态。
2. **创建一个栈**：用于保存每次递归调用的状态。
3. **初始化栈**：将初始状态压入栈中。
4. **循环处理栈**：
    - 从栈顶弹出当前状态。
    - 处理当前状态：
        - 如果是基本情况（base case），进行相应的处理。
        - 如果不是基本情况，将子问题分解，并将新的状态压入栈中。
5. **终止条件**：当栈为空时，循环结束。

#### 示例：阶乘的递归转循环

**递归版本**：
```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
```

**循环版本（直接迭代）**：
```python
def factorial(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result
```

这个例子比较简单，可以直接用循环实现，不需要显式使用栈。但对于更复杂的递归，可能需要使用栈。

#### 示例：树的深度优先搜索（DFS）递归转循环

**递归版本**：
```python
def dfs(node):
    if node is None:
        return
    print(node.value)
    dfs(node.left)
    dfs(node.right)
```

**循环版本（使用栈）**：
```python
def dfs(root):
    if root is None:
        return
    stack = [root]
    while stack:
        node = stack.pop()
        print(node.value)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
```

在这个例子中，我们显式地使用了一个栈来模拟递归的调用顺序。注意，右子节点先入栈，左子节点后入栈，以保证左子节点先被处理。

### 尾递归的特殊情况

**尾递归（Tail Recursion）**是一种特殊的递归形式，其中递归调用是函数中的最后一步操作。尾递归可以被编译器或解释器优化为循环，从而避免栈的增长。

**尾递归示例**：
```python
def factorial(n, accumulator=1):
    if n == 0:
        return accumulator
    else:
        return factorial(n - 1, n * accumulator)
```

**转换为循环**：
```python
def factorial(n):
    accumulator = 1
    while n != 0:
        accumulator *= n
        n -= 1
    return accumulator
```

对于尾递归，转换更为直接，因为不需要保存多个栈帧的状态。

### 非尾递归的转换

对于非尾递归，如前面提到的树DFS，需要显式使用栈来保存中间状态。这是因为在递归过程中，函数需要在递归调用返回后进行额外的操作（如乘法、合并结果等），因此需要保存这些上下文。

### 通用范式总结

基于以上分析，将递归转换为循环的通用范式可以总结如下：

1. **识别递归函数的参数和局部变量**：这些是需要保存的状态。
2. **创建一个栈**：用于保存这些状态。
3. **初始化栈**：将初始参数压入栈。
4. **循环处理**：
    - 弹出栈顶状态。
    - 如果是基本情况，处理并可能将结果返回或累积。
    - 如果不是基本情况，将问题分解为子问题，并将子问题的状态按适当的顺序压入栈（可能需要逆序，以保持与原递归相同的处理顺序）。
5. **终止**：当栈为空时，循环结束。

### 其他注意事项

- **递归与迭代的选择**：虽然递归可以转换为循环，但并非所有情况下都需要这样做。递归在表达某些算法时更为清晰和直观，尤其是在处理递归定义的数据结构（如树、图）时。
- **性能考量**：递归的函数调用开销可能较大，但现代编译器和解释器对尾递归有优化。在性能敏感的场景下，可以考虑转换为循环。
- **栈的限制**：对于深度很大的递归，转换为循环可以避免栈溢出，尤其是在栈空间有限的系统中。

### 反例思考

是否存在无法转换为循环的递归？从理论上看，没有。因为递归和循环在计算能力上是等价的。但在实践中，某些递归可能难以直观地转换为循环，尤其是涉及多个递归调用或复杂的状态管理时。然而，通过系统地使用栈来保存状态，总是可以实现的。

### 实际应用中的例子

让我们再看一个更复杂的例子：汉诺塔问题。

**递归版本**：
```python
def hanoi(n, source, target, auxiliary):
    if n == 1:
        print(f"Move disk 1 from {source} to {target}")
    else:
        hanoi(n - 1, source, auxiliary, target)
        print(f"Move disk {n} from {source} to {target}")
        hanoi(n - 1, auxiliary, target, source)
```

**循环版本（使用栈）**：
```python
def hanoi(n, source, target, auxiliary):
    stack = []
    stack.append((n, source, target, auxiliary, False))
    
    while stack:
        current = stack.pop()
        n, source, target, auxiliary, processed = current
        if n == 1:
            print(f"Move disk 1 from {source} to {target}")
        else:
            if not processed:
                # Push back with processed=True
                stack.append((n, source, target, auxiliary, True))
                # Push the first recursive call
                stack.append((n - 1, source, auxiliary, target, False))
            else:
                print(f"Move disk {n} from {source} to {target}")
                # Push the second recursive call
                stack.append((n - 1, auxiliary, target, source, False))
```

在这个例子中，我们需要在栈中保存额外的信息（如`processed`标志）来跟踪是否已经处理了当前节点的打印操作。这展示了对于更复杂的递归，转换时需要更细致的状态管理。

### 更通用的递归转循环模式

对于一般的递归函数，可以按照以下模式进行转换：

1. **定义栈帧**：将递归函数的参数和局部变量封装为一个栈帧。
2. **初始化栈**：将初始栈帧压入栈。
3. **循环处理**：
    - 弹出栈帧。
    - 根据栈帧的状态（如阶段或是否已处理）决定下一步：
        - 如果是基本情况，处理并可能累积结果。
        - 如果不是基本情况，分解为子问题，将当前栈帧（可能更新状态）和子问题的栈帧按顺序压入栈。
4. **返回结果**：当栈为空时，返回累积的结果。

### 结论

经过以上的思考和示例分析，可以得出以下结论：

1. **所有递归都可以改写为循环**：从理论上看，递归和循环在计算能力上是等价的，任何递归算法都可以通过使用栈来显式模拟递归的调用过程，从而转换为循环。
2. **存在通用的转换范式**：
    - 对于尾递归，可以直接转换为循环，无需栈。
    - 对于非尾递归，可以使用栈来保存中间状态，按照递归的执行顺序进行迭代处理。
3. **实际转换的复杂性**：
    - 简单的递归（如阶乘、斐波那契数列）可以直接用循环重写。
    - 复杂的递归（如树遍历、汉诺塔）需要显式使用栈来管理状态，转换可能较为复杂。

因此，虽然所有递归都可以转换为循环，但转换的难易程度取决于递归的具体形式和复杂性。在实际编程中，应根据具体情况选择最适合的方法，权衡代码的可读性、性能和可维护性。


# 回溯算法和递归是计算机科学中常用的概念，它们有一定的联系，但也有明显的区别。以下是它们的区别与联系的清晰说明：

### **1. 定义**
- **递归 (Recursion)**：
    - 递归是一种**编程技术**，指一个函数在执行过程中直接或间接调用自身来解决问题。
    - 递归的核心是将问题分解为更小的子问题，子问题的结构与原问题相同，最终通过解决子问题来解决原问题。
    - 递归通常有明确的**终止条件**（base case）和递归调用（recursive case）。
    - 示例：计算阶乘 `n!`，通过 `n! = n * (n-1)!` 递归定义。

- **回溯算法 (Backtracking)**：
    - 回溯算法是一种**搜索算法**，通过**递归**的方式在解空间中系统地探索所有可能的解，并在发现某条路径不可行时“回溯”到上一个状态，尝试其他路径。
    - 回溯的核心是**试探和撤销**：尝试一种选择，如果不行则撤销（回溯）并尝试其他选择。
    - 回溯通常用于解决**组合、排列、子集**等需要穷举的问题，如八皇后问题、迷宫问题。

### **2. 联系**
- **回溯算法基于递归**：回溯算法通常通过递归来实现，递归是回溯的底层机制。回溯算法利用递归在解空间中深度优先搜索（DFS），通过递归调用来推进搜索，回到上层调用来实现“回溯”。
- **共同点**：两者都涉及函数调用自身，都需要定义终止条件以避免无限循环。

### **3. 区别**
| **方面**           | **递归**                                   | **回溯算法**                              |
|---------------------|-------------------------------------------|------------------------------------------|
| **本质**           | 一种编程技术，用于分解问题。                | 一种基于递归的搜索算法，强调试探和撤销。  |
| **目的**           | 解决任何可分解为子问题的计算问题。          | 寻找满足条件的解，通常用于组合优化问题。  |
| **状态管理**       | 不一定需要维护和撤销状态。                  | 需要维护状态（如路径、选择），并在回溯时撤销。 |
| **适用场景**       | 广泛，如阶乘、斐波那契数、树遍历等。        | 特定于搜索和穷举，如八皇后、子集生成等。  |
| **回溯行为**       | 不涉及“撤销”操作，仅分解和合并结果。        | 明确涉及“试探-撤销”操作，动态调整选择。   |
| **复杂度**         | 取决于问题，可能简单（如O(log n)）。        | 通常指数级复杂度（如O(2^n)），因需穷举。  |

### **4. 示例对比**
- **递归示例：计算斐波那契数**
  ```python
  def fib(n):
      if n <= 1:
          return n  # 终止条件
      return fib(n-1) + fib(n-2)  # 递归调用
  ```
    - 这里递归仅分解问题并合并结果，无需撤销状态。

- **回溯示例：全排列问题**
  ```python
  def permute(nums):
      def backtrack(path, options):
          if len(path) == len(nums):  # 终止条件
              result.append(path[:])
              return
          for num in options:
              path.append(num)  # 做选择
              backtrack(path, [x for x in options if x != num])  # 递归
              path.pop()  # 撤销选择
      result = []
      backtrack([], nums)
      return result
  ```
    - 回溯通过递归推进搜索，显式地添加选择（`path.append`）和撤销选择（`path.pop`），以尝试所有可能组合。

### **5. 总结**
- **递归**是更广义的概念，是一种分解问题的方法，适用于各种场景。
- **回溯算法**是递归的一种具体应用，专为搜索和穷举问题设计，强调状态的试探和撤销。
- 如果你在解决一个问题时需要“尝试所有可能性”并在失败时“撤销尝试”，那就是回溯算法；如果只是将问题分解为子问题并合并结果，那就是普通递归。

如果你有具体问题或代码想深入探讨，可以进一步说明！

---

是的，如果不使用递归，也不想通过手工模拟栈来改写递归算法，通常需要对算法的逻辑本身进行改写，以适应循环的执行方式。这是因为递归和循环在处理问题时有着本质上的不同：

1. **递归的特性**：
    - 递归通过函数调用自身来分解问题，每层递归依赖调用栈保存中间状态（如参数、局部变量等）。
    - 递归逻辑通常是基于问题的自然分解，层层深入直到满足终止条件，然后回溯合并结果。

2. **循环的特性**：
    - 循环通过迭代的方式逐步处理问题，通常需要显式地管理状态（如通过变量存储中间结果）。
    - 循环更适合线性或顺序执行的逻辑，不依赖调用栈。

3. **不使用手工栈的改写**：
    - 如果不希望通过手工模拟栈（即显式地使用数据结构如栈来保存递归状态），那么需要将递归的“分而治之”逻辑转换为一种等价的迭代逻辑。这通常意味着：
        - **重新设计状态管理**：需要用变量或数据结构来替代递归调用栈中隐式存储的状态。
        - **改变控制流**：递归的深度优先或分层处理需要被转换为循环的顺序处理，可能需要重新组织算法的执行顺序。
        - **合并结果的方式**：递归中通过回溯自然合并结果的部分，可能需要在循环中显式地维护结果的累积。

4. **是否需要改写逻辑本身**：
    - 是的，通常需要改写逻辑本身，因为递归的分解方式和循环的迭代方式在思维模型上不同。例如：
        - 递归中，问题被分解为子问题，子问题的解通过回溯合并。
        - 循环中，必须显式地跟踪所有子问题的状态，并以某种顺序处理。
    - 改写时，可能会改变算法的时间或空间复杂度。例如，某些递归算法（如快速排序）改成循环后，可能需要额外的空间来模拟递归的行为，而如果不使用栈，可能需要完全不同的算法设计。

5. **具体示例**：
    - 以计算斐波那契数列为例：
        - **递归方式**：
          ```python
          def fib(n):
              if n <= 1:
                  return n
              return fib(n-1) + fib(n-2)
          ```
          递归逻辑是基于数学定义，直接分解问题。
        - **循环方式（不使用栈）**：
          ```python
          def fib(n):
              if n <= 1:
                  return n
              a, b = 0, 1
              for _ in range(2, n + 1):
                  a, b = b, a + b
              return b
          ```
          这里逻辑被完全改写为迭代形式，使用两个变量 `a` 和 `b` 来跟踪前两个数的状态，避免了递归调用和栈的使用。
        - **差异**：递归版本依赖调用栈，逻辑直观但效率低（指数复杂度）；循环版本重新设计为线性迭代，复杂度降为 O(n)，但逻辑不再直接反映数学定义。

6. **改写逻辑的挑战**：
    - **复杂问题**：对于复杂递归（如树遍历、图算法），改写为循环可能需要重新设计数据处理顺序（如用队列替代递归的深度优先搜索）。
    - **状态管理**：需要仔细设计变量来保存递归中隐含的状态，可能会增加代码复杂度。
    - **算法选择**：某些递归算法（如分治法）改成循环可能不如直接选择更适合迭代的算法（如动态规划）。

**总结**：
是的，不使用手工栈将递归改写为循环通常需要改变算法的逻辑本身。这要求重新设计状态管理和控制流，以适应迭代的执行方式。改写的复杂度取决于原递归算法的结构，简单问题（如斐波那契）可能只需少量调整，而复杂问题（如深度优先搜索）可能需要彻底重新设计算法逻辑。

---

要将递归改写为使用栈的迭代形式，我们需要显式地用栈来模拟递归调用栈的行为，保存每次递归调用的状态（如参数、局部变量等）。以下以斐波那契数列和二叉树的前序遍历为例，展示如何用栈实现递归逻辑，而不改变递归的核心逻辑。

### 示例 1：斐波那契数列
递归版本的斐波那契数列计算：
```python
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
```

用栈改写为迭代版本，模拟递归调用栈：
```python
def fib(n):
    if n <= 1:
        return n
    
    # 使用栈保存递归状态，栈中存储 (k, state) 表示计算 fib(k) 的状态
    stack = [(n, 0)]  # state=0 表示初始状态，1 表示等待 fib(n-1)，2 表示等待 fib(n-2)
    results = {}  # 缓存已计算的 fib 值，避免重复计算
    
    while stack:
        k, state = stack.pop()
        
        if k <= 1:
            results[k] = k
            continue
            
        if state == 0:
            # 初始状态，分解为 fib(k-1) + fib(k-2)
            stack.append((k, 1))  # 下一步等待 fib(k-1)
            stack.append((k-1, 0))  # 计算 fib(k-1)
        elif state == 1:
            # 已得到 fib(k-1)，需要计算 fib(k-2)
            stack.append((k, 2))  # 下一步等待 fib(k-2)
            stack.append((k-2, 0))  # 计算 fib(k-2)
        elif state == 2:
            # 已得到 fib(k-1) 和 fib(k-2)，合并结果
            results[k] = results.get(k-1, 0) + results.get(k-2, 0)
    
    return results[n]
```

**说明**：
- 栈中存储 `(k, state)`，`k` 表示当前计算的斐波那契数，`state` 表示递归的阶段（0: 初始，1: 等待 `fib(k-1)`，2: 等待 `fib(k-2)`）。
- 使用 `results` 字典缓存中间结果，避免重复计算。
- 每次从栈中弹出状态，根据 `state` 决定下一步操作，模拟递归的分解和回溯。
- 虽然用栈模拟了递归，但时间复杂度仍为 O(2^n)（可通过记忆化优化为 O(n)）。

### 示例 2：二叉树前序遍历
递归版本的二叉树前序遍历（根 -> 左 -> 右）：
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder_recursive(root):
    result = []
    if root:
        result.append(root.val)
        result.extend(preorder_recursive(root.left))
        result.extend(preorder_recursive(root.right))
    return result
```

用栈改写为迭代版本：
```python
def preorder_iterative(root):
    if not root:
        return []
    
    result = []
    stack = [(root, 0)]  # 栈中存储 (node, state)，state=0 表示访问根，1 表示访问左子树，2 表示访问右子树
    
    while stack:
        node, state = stack.pop()
        
        if not node:
            continue
            
        if state == 0:
            # 访问根节点
            result.append(node.val)
            stack.append((node, 1))  # 下一步访问左子树
        elif state == 1:
            # 访问左子树
            stack.append((node, 2))  # 下一步访问右子树
            stack.append((node.left, 0))  # 访问左子树
        elif state == 2:
            # 访问右子树
            stack.append((node.right, 0))  # 访问右子树
    
    return result
```

**说明**：
- 栈中存储 `(node, state)`，`node` 是当前节点，`state` 表示处理阶段（0: 访问根，1: 访问左子树，2: 访问右子树）。
- 通过 `state` 控制访问顺序，模拟递归的深度优先搜索。
- 每次弹出栈顶元素，根据 `state` 决定是输出节点值还是继续压入子节点。
- 这种方式直接模拟了递归的调用栈行为，逻辑与递归一致。

### 更简化的前序遍历（栈的常见用法）
对于前序遍历，可以利用栈的特性进一步简化：
```python
def preorder_iterative_simplified(root):
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        if node:
            result.append(node.val)
            # 右子树先入栈，后访问（栈是后进先出）
            stack.append(node.right)
            stack.append(node.left)
    
    return result
```

**说明**：
- 直接用栈存储节点，右子树先入栈（后访问），左子树后入栈（先访问），符合前序遍历的顺序。
- 这种方式更简洁，但逻辑稍偏离递归的直接模拟，而是利用了栈的 LIFO 特性。

### 关键点
1. **栈的作用**：栈显式地保存递归调用中的状态（如参数、局部变量、执行阶段），替代系统调用栈。
2. **逻辑保留**：使用栈改写时，核心逻辑尽量保持与递归一致，只是将隐式的调用栈变为显式的栈操作。
3. **状态管理**：需要为每个递归调用设计状态（如 `state` 变量），以跟踪执行进度。
4. **适用场景**：用栈改写适合直接模拟递归逻辑，特别是当递归逻辑复杂（如树、图遍历）时，避免完全重写算法。

如果你的递归问题更具体（例如其他算法或数据结构），请提供细节，我可以帮你定制更精确的栈实现代码！


---

好的，我来详细解释你提供的 Python 代码片段的语法和含义：

```python
stack = [(root, 0)]  # 栈中存储 (node, state)，state=0 表示访问根，1 表示访问左子树，2 表示访问右子树
```

### 逐部分解析

1. **变量赋值**：
   ```python
   stack = ...
   ```
    - `stack` 是一个变量名，用来存储一个数据结构。
    - `=` 是 Python 的赋值运算符，将右侧的值赋给左侧的变量 `stack`。

2. **列表初始化**：
   ```python
   stack = [...]
   ```
    - 方括号 `[]` 表示创建一个 **列表**（list），这是 Python 中一种常用的可变序列类型。
    - 列表可以存储任意类型的元素（包括元组、对象等）。

3. **元组 `(root, 0)`**：
   ```python
   (root, 0)
   ```
    - 括号 `()` 表示创建一个 **元组**（tuple），这是 Python 中一种不可变的有序数据结构。
    - 元组 `(root, 0)` 包含两个元素：
        - `root`：一个变量，通常表示二叉树的根节点（例如 `TreeNode` 类型的对象）。
        - `0`：一个整数，表示某种状态（根据注释，`state=0` 表示当前处理的是访问根节点的阶段）。
    - 元组是不可变的，适合用来存储固定状态的组合（如节点和其处理阶段）。

4. **列表中包含元组**：
   ```python
   stack = [(root, 0)]
   ```
    - `[(root, 0)]` 是一个列表，当前只包含一个元素，即元组 `(root, 0)`。
    - 这表示初始化一个栈（stack），并将 `(root, 0)` 作为栈的第一个元素。
    - 栈是一种后进先出（LIFO）的数据结构，这里用列表模拟栈，通过 `append()` 添加元素（入栈），`pop()` 移除元素（出栈）。

5. **注释**：
   ```python
   # 栈中存储 (node, state)，state=0 表示访问根，1 表示访问左子树，2 表示访问右子树
   ```
    - `#` 是 Python 中单行注释的符号，后面内容是给开发者看的说明，不会被执行。
    - 注释解释了栈的用途：
        - 栈中的每个元素是一个元组 `(node, state)`。
        - `node` 表示二叉树中的某个节点。
        - `state` 是一个整数，用于跟踪节点的处理阶段：
            - `state=0`：表示当前要访问节点本身（根）。
            - `state=1`：表示当前要处理节点的左子树。
            - `state=2`：表示当前要处理节点的右子树。
    - 这种设计是为了模拟递归前序遍历（根 -> 左 -> 右）的过程，用 `state` 跟踪每个节点的处理进度。

### 代码的上下文和作用
- 这行代码出现在二叉树前序遍历的迭代实现中，目的是初始化一个栈，用于模拟递归调用栈的行为。
- 具体来说：
    - `root` 是二叉树的根节点，初始时将其压入栈，并标记状态为 `0`（表示先访问根）。
    - 后续代码会通过 `stack.pop()` 取出栈顶元素，根据 `state` 值决定是访问节点值、处理左子树还是右子树，并可能压入新的 `(node, state)` 元组。
- 使用 `(node, state)` 元组的设计，允许在迭代中显式地管理递归的状态，替代了系统调用栈。

### 语法总结
- **`stack`**：变量名，表示用列表实现的栈。
- **`[]`**：创建列表。
- **`(root, 0)`**：元组，存储节点和状态。
- **`root`**：二叉树节点（通常是 `TreeNode` 对象）。
- **`0`**：状态标志，表示初始阶段（访问根）。
- **注释**：解释了栈中元素的结构和 `state` 的含义。

### 示例运行（假设在二叉树遍历中）
假设有以下二叉树：
```
    1
   / \
  2   3
 / \
4   5
```
- 初始：`stack = [(root, 0)]`，其中 `root` 是节点 `1`，`state=0`。
- 后续迭代会通过栈操作模拟前序遍历，输出 `[1, 2, 4, 5, 3]`，而 `state` 帮助控制访问顺序。

如果你有其他关于代码或上下文的问题，请告诉我，我可以进一步细化解释！