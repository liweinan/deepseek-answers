# 好的，SemVer (Semantic Versioning, 语义化版本) 是一套简单而明确的版本号管理规则，旨在帮助开发者和用户理解版本更新的性质，避免“依赖地狱”（dependency hell）。

它的核心思想是，通过版本号的格式来传达底层代码的变更内容。

- https://devhints.io/semver

---

### 1. 核心格式：`MAJOR.MINOR.PATCH`

一个标准的 SemVer 版本号必须采用 `X.Y.Z` 的格式，其中 X, Y, Z 都是非负整数，并且禁止在数字前面加 0（例如 `1.02.3` 是无效的）。

* **`MAJOR` (主版本号)**: 当你做了**不兼容的 API 修改**时，你必须增加主版本号。
    * 例如，你删除了一个公共函数、修改了函数签名、或者改变了函数的行为，导致依赖你的旧版本的代码无法正常工作。
    * `1.7.2` -> `2.0.0`

* **`MINOR` (次版本号)**: 当你以**向后兼容**的方式**添加了新功能**时，你必须增加次版本号。
    * 例如，你增加了一个新的公共函数、给现有 API 增加了可选参数等。依赖你的旧版本的代码仍然可以正常工作。
    * `1.7.2` -> `1.8.0`

* **`PATCH` (修订号)**: 当你做了**向后兼容的 bug 修复**时，你必须增加修订号。
    * 例如，你修复了一个内部实现的错误，但没有改变任何 API 的行为或签名。
    * `1.7.2` -> `1.7.3`

### 2. 特殊情况：0.y.z (初始开发阶段)

当主版本号是 `0` 时（例如 `0.1.0`），表示这个项目处于**初始开发阶段**，其 API 被认为是不稳定的。

在这个阶段，**任何改动都可能包含不兼容的变更**。因此，`^` 和 `~` 符号对 `0.y.z` 版本的处理会更加保守。

### 3. 先行版本 (Pre-release)

如果你想发布一个不稳定的、用于测试的版本，可以在 `MAJOR.MINOR.PATCH` 后面附加一个连字符和一系列由点分隔的标识符。

* **格式**: `X.Y.Z-[标识符]`
* **示例**: `1.0.0-alpha`, `1.0.0-alpha.1`, `1.0.0-beta.2`, `1.0.0-rc.1` (rc = Release Candidate)
* **优先级**: 先行版本的优先级低于其对应的正式版本。例如，`1.0.0-rc.1` 的优先级低于 `1.0.0`。

### 4. npm 中的版本范围符号

在 `package.json` 中，我们通常不写死一个版本，而是指定一个可接受的版本范围。最常见的符号是 `^` 和 `~`。

* **`^` (Caret / 脱字符)**: **“不要改动最左边的非零数字”**
    * 这是 `npm install --save` 的默认行为。
    * 它允许次版本和修订号的更新，但**不允许主版本的更新**（因为主版本更新意味着不兼容）。
    * `^1.2.3` 匹配 `>= 1.2.3` 且 `< 2.0.0` 的所有版本。
    * `^0.2.3` 匹配 `>= 0.2.3` 且 `< 0.3.0` 的所有版本 (因为最左非零数字是 `2`)。
    * `^0.0.3` 只匹配 `>= 0.0.3` 且 `< 0.0.4` 的版本 (因为最左非零数字是 `3`)。

* **`~` (Tilde / 波浪号)**: **“只允许修订号更新”** (如果指定了次版本号)
    * 它比 `^` 更保守。
    * `~1.2.3` 匹配 `>= 1.2.3` 且 `< 1.3.0` 的所有版本 (只允许 patch 更新)。
    * `~1.2` 匹配 `>= 1.2.0` 且 `< 1.3.0` 的所有版本 (相当于 `1.2.x`)。
    * `~1` 匹配 `>= 1.0.0` 且 `< 2.0.0` 的所有版本 (相当于 `1.x`)。

* **其他符号**:
    * `*` 或 `x`: 匹配任意版本。
    * `>`,`<`,`>=`,`<=`: 指定范围。
    * `1.2.3 - 2.3.4`: 指定一个闭区间范围。
    * `||`: “或”逻辑，用于组合多个范围，例如 `^1.0.0 || ^2.0.0`。

通过遵循 SemVer，库的作者可以清晰地向用户传达更新的风险等级，而用户则可以通过 `package.json` 中的版本范围来控制自己愿意承担的更新风险，从而实现更稳定、可预测的依赖管理。

好的，我们来把 `~` (Tilde / 波浪号) 这个符号彻底讲清楚。

你说得对，“只允许修订号更新”这个说法虽然没错，但确实有点抽象。

一个更具体、更准确的“黄金法则”是：

**`~` 会保持你指定的 `主版本号` 和 `次版本号` 不变，只允许 `修订号` 增长。**

让我们通过几个例子来分解这个法则：

---

### 场景 1：最常见的用法 `~1.2.3`

假设你在 `package.json` 中写了：`"some-package": "~1.2.3"`

* **分析**:
    * 你指定的主版本号是 `1`。
    * 你指定的次版本号是 `2`。
    * 你指定的修订号是 `3`。

* **规则**:
    * 主版本号**必须**是 `1`。
    * 次版本号**必须**是 `2`。
    * 修订号**必须**大于或等于 `3`。

* **换句话说，这等价于版本范围**: `>= 1.2.3` 并且 `< 1.3.0`。

* **具体匹配情况**:
    * `1.2.3` -> **匹配** (这是最低版本)
    * `1.2.4` -> **匹配** (修订号增加了)
    * `1.2.99` -> **匹配** (修订号增加了)
    * `1.2.2` -> **不匹配** (修订号太旧了)
    * `1.3.0` -> **不匹配** (次版本号变了，这是 `~` 不允许的)
    * `2.0.0` -> **不匹配** (主版本号变了)

**核心目的**: 你告诉 npm：“我依赖 `some-package` 的 `1.2` 版本，我相信这个版本后续的 bug 修复（比如 `1.2.4`），但我不想冒任何风险去使用可能包含新功能的 `1.3.0` 版本，即使它号称是向后兼容的。”

---

### 场景 2：只指定主次版本 `~1.2`

这其实是场景 1 的一种简写，它被 npm 解释为 `~1.2.0`。

* **`"some-package": "~1.2"`** 等价于 **`"some-package": "~1.2.0"`**
* **匹配范围**: `>= 1.2.0` 并且 `< 1.3.0`。
* **也等价于**: `1.2.x`

---

### `~` (Tilde) vs. `^` (Caret) 的关键区别

现在对比一下默认的 `^`，你就能彻底明白 `~` 的用途了。

| 版本范围 | 匹配 `1.2.4`? | 匹配 `1.3.0`? | 匹配 `1.3.5`? | 匹配 `2.0.0`? | 风险等级 |
| :--- | :---: | :---: | :---: | :---: | :--- |
| `~1.2.3` | ✅ | ❌ | ❌ | ❌ | **最低** (只接受 bug 修复) |
| `^1.2.3` | ✅ | ✅ | ✅ | ❌ | **中等** (接受 bug 修复和新功能) |

**总结一下：**

* `^` (默认) 说：“我相信这个库的作者，只要不升级主版本，新功能和 bug 修复我都要。”
* `~` (更保守) 说：“我只想要 bug 修复。任何新功能，哪怕是兼容的，我都暂时不想要，因为新功能可能引入新 bug。我要等我准备好了再手动升级次版本。”

在一些对稳定性要求极高、不希望任何非预期行为变化的项目中，开发者会选择使用 `~` 来锁定次要版本，以获得最大的可预测性。

---


当然，这是一个非常好的深化问题。`~` 和 `^` 的行为在主版本号为 `0` 和不为 `0` 时有关键区别。下面是详细的对比表格。

### 表格 1: 主版本号 >= 1 (例如 `1.x.y`)

这是最常见的情况，用于稳定版本的依赖。

| 输入版本 | 符号 | 等价范围 | 解释 |
| :--- | :--- | :--- | :--- |
| **`1.2.3`** | `~` | `>= 1.2.3 < 1.3.0` | **只允许修订号更新**。锁定主版本 `1` 和次版本 `2`。 |
| | `^` | `>= 1.2.3 < 2.0.0` | **允许次版本和修订号更新**。只锁定主版本 `1`。 |
| **`1.2`** | `~` | `>= 1.2.0 < 1.3.0` | **只允许修订号更新**。锁定 `1.2`。 |
| | `^` | `>= 1.2.0 < 2.0.0` | **允许次版本和修订号更新**。锁定 `1`。 |
| **`1`** | `~` | `>= 1.0.0 < 2.0.0` | **允许次版本和修订号更新**。因为未指定次版本，行为与 `^` 相同。 |
| | `^` | `>= 1.0.0 < 2.0.0` | **允许次版本和修订号更新**。 |

**核心区别**: 当指定了次版本号（如 `1.2` 或 `1.2.3`）时，`~` 比 `^` 更严格，它会把次版本号也锁定。

---

### 表格 2: 主版本号为 0 (例如 `0.x.y`)

这种情况用于初始开发阶段 (API 不稳定)，`^` 的行为会变得更加保守，以避免引入破坏性更新。

| 输入版本 | 符号 | 等价范围 | 解释 |
| :--- | :--- | :--- | :--- |
| **`0.2.3`** | `~` | `>= 0.2.3 < 0.3.0` | **只允许修订号更新**。锁定 `0.2`。 |
| | `^` | `>= 0.2.3 < 0.3.0` | **只允许修订号更新**。对于 `0.x.y` (x>0)，`^` 的行为退化为与 `~` 相同。 |
| **`0.2`** | `~` | `>= 0.2.0 < 0.3.0` | **只允许修订号更新**。锁定 `0.2`。 |
| | `^` | `>= 0.2.0 < 0.3.0` | **只允许修订号更新**。对于 `0.x` (x>0)，`^` 的行为退化为与 `~` 相同。 |
| **`0.0.3`** | `~` | `>= 0.0.3 < 0.1.0` | **只允许修订号更新**。锁定 `0.0`。 |
| | `^` | `>= 0.0.3 < 0.0.4` | **不允许任何更新**。`^` 的规则是锁定最左非零数字，这里是 `3`，所以版本被完全锁定。 |
| **`0`** | `~` | `>= 0.0.0 < 1.0.0` | **允许次版本和修订号更新**。因为未指定次版本，行为与 `^` 相同。 |
| | `^` | `>= 0.0.0 < 1.0.0` | **允许次版本和修订号更新**。 |

**核心区别**:
1. 对于 `0.x.y` (且 x > 0)，`^` 和 `~` 的行为**完全相同**。
2. 对于 `0.0.y`，`^` 会**完全锁定**版本，比 `~` 更严格。
3. 如果只指定主版本（`1` 或 `0`），`^` 和 `~` 的行为**没有区别**。